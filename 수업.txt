using System.Diagnostics;
using System.Globalization;
using System.Net;

namespace C_study20250222
{
    internal class Program
    {
        static void Main(string[] args)
        {
            ///*변수의 선언, 변수형*/
            //Console.WriteLine("Hello world!!");
            //int age = 26;
            //Console.WriteLine(age);
            ///*int, short, long, byte 정수형
            //string 문자열
            //char 문자
            //변수에는 데이터(값)이 하나만 저장할 수 있다.*/
            //string name = "Hello";
            //short age1 = 26;
            //long age2 = 26;
            //byte age3 = 26;
            //Console.WriteLine(name);
            //Console.WriteLine(age1);
            //Console.WriteLine(age2);
            //Console.WriteLine(age3);

            ///*
            //부동 소수점(실수)
            //소수의 범위를 정함으로서 실수를 근사적으로 표현
            //소수점의 위치가 고정x, 수의 범위와 정밀도에 따라 변할 수 있음
            //컴퓨터에서 수를 저장할때 정수 부분과 소수 부분을 나누어 저장//(정수).(소수)
            //*/
            //double a;//4byte(6~7자리)
            //float b;//8byte(15~16자리)
            //decimal c;//16byte(28~29자리)
            //a = 5.78;//double {*.**(d)}
            //b = 3.57f;//float {*.**f(F)}
            //c = 2.4567m;//decimal {*.**m(M)}
            //Console.WriteLine(a);
            //Console.WriteLine(b);
            //Console.WriteLine(c);
            ///*
            // 불리언 데이터
            // 참/거짓(true/false)을 나타내는데 사용
            // 1/0                                  
            //*/
            //bool isCsharp = false;
            //bool isSunday = true;
            ///*
            // 문자/문자열
            //char(문자)//2byte
            //string(문자열)//최대 2048byte
            //*/
            //char mychar = 'c';
            //char hanguel = '한';
            //string mystring = "mystring";
            //string mystring2 = "한글";
            //Console.WriteLine(mystring);
            //Console.WriteLine(hanguel);
            //Console.WriteLine(mychar);
            //Console.WriteLine(mystring2);
            ///*문자열 포멧팅
            // * 복잡한 데이터를 보기 좋게 표현
            // * 코드의 가시성 상승=> 코드짜기 편하다
            // * $기호화 []를 사용
            //*/
            //int a1 = 1;
            //int b1 = 3;
            //string format1 = $"3 * {a1} = {b1}";
            //Console.WriteLine(format1);
            ///*문자열+문자열*/

            //mystring2 = mystring2 + "입니다.";
            //Console.WriteLine(mystring2);
            ///*연산자
            // +, -, /, *, %
            //*/
            //int int1 = (10 - 4) * 3;
            //Console.WriteLine(int1);
            //int1 = int1 + 3;
            //Console.WriteLine(int1);
            //int1 += 3;
            //Console.WriteLine(int1);
            //int1 -= 3;
            //Console.WriteLine(int1);
            //int1 *= 3;
            //Console.WriteLine(int1);
            //int1 /= 3;
            //Console.WriteLine(int1);

            ///*비교 연산자
            // ==, !=, <, <=, >, >=
            // */
            //bool isequal = (21 == a1);
            //bool isnotequal = (21 != a1);
            //Console.WriteLine($"Is Equal:{isequal}");
            //Console.WriteLine($"Is not Equal:{isnotequal}");

            ///*논리 연산자
            // AND, OR, NOT, NOR, NAND
            // */
            //bool And = (isequal && isnotequal);
            //Console.WriteLine($"AND:{And}");
            //bool Or = (isequal || isnotequal);
            //Console.WriteLine($"OR:{Or}");
            //bool Not = !Or;
            //Console.WriteLine($"NOT:{Not}");
            //bool isMan = true;
            //bool isStudent = true;
            //bool isMonday = false;
            //if (isMan && isStudent && !isMonday)
            //{
            //    Console.WriteLine("Man and Student,Not Monday");
            //}
            //Console.WriteLine(isMan || isMonday);

            ///*증감 연산자
            // 값을 1씩 증가, 감소 시키는 연산자
            //++, --
            //a++ 이 코드가 실행되고 나서 1을 증가시킨다.
            //++a 이 코드를 실행되기 전에 1을 증가시킨다.
            // */
            //int a3 = 0;
            //for (int i = 0; i < int1; i++)
            //{
            //    Console.WriteLine(a3);
            //    a3++;
            //}
            ///*증감 연산자를 같은 줄의 코드에 사용될때 주의점*/
            //int a2 = 10;
            //Console.WriteLine(a2++);//a2(10)를 먼저 출력 후 +1(후위)
            //Console.WriteLine(++a2);//a2(11)에 +1 후에 a2(12)를 출력(전위)

            ///*캐스팅
            // 데이터 타입을 변환하는 방법
            //1. 암시적 캐스팅
            //변환되는 데이터가 원본 데이터보다 더 큰 범위를 가질때, 더 많은 정보를 저장할때 발생
            //2. 명시적 캐스팅
            //변환되는 데이터가 원본 데이터버다 더 작은 범위를 가질때, 더 적은 정보를 저장할때 발생
            //*/
            //int a4 = 1000000000;
            //long b4 = a4;//암시적

            //long b5 = 1000000000;
            //int a5 = (int)b5;//명시적, long은 int 보다 더 큰 범위를 가지기 때문에 int데이터에 long을암시적을로 넣을 수 없다.따라서 명시적으로 (int)c 형식으로 선언하여 데이터 타입의 전환을 강제할 수 있다.이때 데이터 범위가 작아지기 때문에 데이터 손실잉 발생할 수 있다.

            //float a6 = 14.25f;
            //int b6 = (int)a6;
            //Console.WriteLine(b6);
            //int result = 10 / 3;
            //Console.WriteLine(result);
            //float Fresult = 10 / 3.0f;
            //Console.WriteLine(Fresult);
            //int num1 = 10;
            //int num2 = 3;
            //float op = num1 / (float)num2;
            //Console.WriteLine(op);

            ///*조건문
            // if(조건->true, false/비교, 논리, bool){
            //        if문의 조건이 true일때 실행될 코드
            //    }
            //else{
            //        if문의 조건이 false일때 실행될 코드//기본적으로는 선언 하지 않아도 된다.
            //        else문은 if문 바로 뒤에 사용되어야 한다. 중간에 다른 코드가 들어갈 ㅅ후 ㅇ벗다
            //    }
            // */
            //if (10>5) 
            //{
            //    Console.WriteLine("10은 5보다 크다");
            //    if (10>9) {
            //        Console.WriteLine("10은 9보다도 크다.");
            //    }
            //}
            //else
            //{
            //    Console.WriteLine("10은 5보다 크지 않다.");
            //}

            //int grade = 7;
            //string tear;
            //if (grade >= 90)
            //{
            //    tear = "A";
            //}
            //else if (grade >= 80)
            //{
            //    tear = "B";
            //}
            //else if(grade >= 70)
            //{
            //    tear = "C";
            //}
            //else if (grade >= 60)
            //{
            //    tear = "D";
            //}
            //else
            //{
            //    tear = "F";
            //}
            //if(grade%10>=5 && tear != "F")
            //{
            //    tear += "+";
            //}

            //Console.WriteLine(tear);

            //int grade1 = 94;
            //string tear1;
            //switch (grade1/10)
            //{
            //    case 10:   
            //    case 9:
            //        {
            //            tear1 = "A";
            //        }
            //        break;
            //    case 8:
            //        {
            //            tear1 = "B";
            //        }
            //        break;
            //    case 7:
            //        {
            //            tear1 = "C";
            //        }
            //        break;
            //    case 6:
            //        {
            //            tear1 = "D";
            //        }
            //        break;
            //    default:
            //        {
            //            tear1 = "F";
            //        }
            //        break;
            //}
            //if (grade1 % 10 > 5 && tear1!="F" || grade1==100)
            //    tear1 += "+";

            //Console.WriteLine(tear1);

            ///*콘솔창에서 입력 받기
            // Console.Readline();
            // */
            //Console.WriteLine("**데이터값 입력**");
            //string input = Console.ReadLine();//기본적으로 string 값/문자열로만 받는다. 숫자로 변환하고 싶을 때
            //Console.WriteLine($"입력 받은 값 : {input}");

            /*문제) 사용자로부터 날씨를 입력 받고, 해당하는 메세지 출력*/
            //맑음 => "오늘의 날씨가 좋네요"
            //비 => "우산을 챙기세요"
            //눈 => "따뜻하게 입으세요"
            //나머지 => "날씨 정보를 알 수 없습니다."

            //Console.Write("오늘의 날씨를 입력하세요(맑음/비/눈) : ");
            //string weather=Console.ReadLine();
            //switch (weather)
            //{
            //    case "맑음":
            //        Console.WriteLine("오늘의 날씨가 좋네요.");
            //        break;
            //    case "비":
            //        Console.WriteLine("우산을 챙기세요.");
            //        break;
            //    case "눈":
            //        Console.WriteLine("따뜻하게 입으세요.");
            //        break;
            //    default:
            //        Console.WriteLine("날씨 정보를 알 수 없습니다.");
            //        break;
            //}

            ///*Parse
            // *문자열 데이터를 다른 데이터 타입으로 변환하는 기능
            // */
            //Console.Write("숫자를 입력해 주세요 : ");
            //string input =Console.ReadLine();
            //int value = int.Parse(input);
            //Console.Write(value);
            ///*문제)놀이동산 입장권
            // * 사용자로부터 나이, 군인할인, 연간 회원 여부를 입력받아서 입장요금을 계산
            // * 1.무료입장 조건: 나이가 3세이하 65세이상, 연간 회원
            // * 2.할인 적용: 군인 30%할인
            // * 3.일반 요금:성인(19~64세)10,000원, 청소년(13~18세)8,000원, 어린이(4~12세)5,000원
            // * 
            // * 나이를 입력하세요:(나이)
            // * 군인인가요?(네/아니요):
            // * 연산 회원인가요?(네/아니요):
            // * 입장료는 000원 입니다./무료 입장입니다.
            // */

            //직접 풀어본 코드
            //Console.Write("나이를 입력하세요 : ");
            //string age = Console.ReadLine();
            //int age1= int.Parse(age);
            //Console.Write("군인인가요?(네/아니요) : ");
            //string isSol = Console.ReadLine();
            //Console.Write("연간 회원인가요?(네/아니요) : ");
            //string isMem = Console.ReadLine();

            //double price=0;

            //if (age1 >= 65 || isMem == "네" || age1 <= 3)
            //{
            //    Console.WriteLine("무료 입장입니다.");
            //}
            //else
            //{
            //    if (age1 <= 64 && age1 >= 19)
            //        price = 10000;
            //    else if (age1 <= 18 && age1 >= 13)
            //        price = 8000;
            //    else if (age1 <= 12 && age1 >= 4)
            //        price = 5000;
            //    if (isSol == "네")
            //        price *= 0.7;
            //}

            //Console.WriteLine($"입장료는 {price}원 입니다.");

            ///*예시*/
            //int adult = 10000;
            //int youth = 8000;
            //int child = 5000;

            //Console.Write("나이를 입력하세요 : ");
            //string _Age = Console.ReadLine();
            //int _Age1 = int.Parse(_Age);
            //Console.Write("군인인가요?(네/아니요) : ");
            //string _isSol = Console.ReadLine();
            //Console.Write("연간 회원인가요?(네/아니요) : ");
            //string _isMem = Console.ReadLine();
            ////요금 계산
            //float pay = 0;
            //if (_Age1 >= 65 || _Age1 <= 3)//나이가 65이상 OR 3세 이하
            //{
            //    pay = 0;
            //}
            //else if (_Age1 <= 64 && _Age1 >= 19)//19세 이상 And 64세 이하
            //    pay = adult;
            //else if (_Age1 <= 18 && _Age1 >= 13)//18세 이상 And 13세 이하
            //    pay = youth;
            //else//4세 이상 And 12세 이하
            //    pay = child;
            //if (_isSol == "네")
            //{
            //    //현재 apy*0.7 == 70% 할인된 가격
            //    //pay *= 0.7f;//int형 변수는 소수점을 계산하지 못하기 때문에 float, double형을 바꾸어 주어야한다             
            //    //float temp = (pay * 0.7f); //값이 6999.1535... 식으로 나올 수 있음.        
            //    //pay = (int)temp;
            //    pay = (int)(pay * 0.7f); //pay * 0.7f을 먼저 계산한 후에 int형으로 바꾸기 위해 ()를 써주어야한다.
            //}
            //if (_isMem == "네")
            //    pay = 0;

            //if(pay==0)
            //    Console.WriteLine("무료 입장입니다.");
            //else
            //    Console.WriteLine($"입장료는 {pay}원 입니다.");

            ///*반복문
            // * 코드를 반복적으로 실행=>언제까지 반복을 실핼할 것인가?(중요)//프로그래머가 정의
            // * 크게 아래 3개로 나뉜다
            // * 1.while(언제까지 반복될건지 값이 true면 반복//false가 될때까지 반복)
            // *  {
            // *      반복적으로 실행될 코드
            // *  }
            // * 2.for(몇번 실행할건지에 대한 조건/변수(정수);조건;변수처리{사칙연산, 증감})
            // * {
            // *      반복적으로 실행될 코드
            // * }
            // * 3.do {
            // * 
            // * }while() 기본적으로 while문과 비슷하지만 코드를 무조건 한번은 실행 시킨다.
            // * {
            // *      
            // * }
            // */
            //int count = 1;
            //while (count < 10)
            //{
            //    count++;//count < 10 일때 코드가 실행
            //    Console.WriteLine(count);
            //}
            //Console.WriteLine($"&반복문이 끝났습니다. count는 {count}입니다.");
            //int count = 1;
            //while (true)//무한 루프(무한 루프안에 무한루프를 넣는 것을 기피해야한다.)반복문이 끝나지 않고 계속 실행되는 현상
            //{
            //    Console.WriteLine(count);
            //    count++;
            //    if (count > 10)
            //    {
            //        break;//break;를 만나면 반복문이 종료된다.
            //    }
            //}
            //반복문이 실행될 때 특정 순간에 그냥 스킵하고 싶을때 사용하는 키워드 ==> countinue
            //continue를 만나면 나머지를 실행하지 않고 반복문의 조건을 비교하는 부분으로 스킵한다.
            //int count = 1;
            //while (true)//무한 루프(무한 루프안에 무한루프를 넣는 것을 기피해야한다.)반복문이 끝나지 않고 계속 실행되는 현상
            //{
            //    if (count%2 == 0)
            //    {
            //        count++;
            //        continue;//짝수일 때 아래코드를 스킵한다.
            //    }
            //    Console.WriteLine(count);
            //    count++;
            //    if (count > 100)
            //        break;
            //}
            //do
            //{
            //    Console.WriteLine("Hello World!");//한번은 무조건 실행된다.
            //} while (false);
            //for (int i = 0; i< 10; i+=2)//외부에서 변수를 가져와도 된다.단 변수를 초기화 해줘야한다. 조건에 true를 넣을 경우 무한 루프
            //{
            //    Console.WriteLine(i);//int i를 선언했기때문에 변수i를 사용할 수 있다.but for문 밖에서는 접근할 수 없다.
            //}//break;, continue; 또한 사용 가능

            ///*문제
            // * 구구단
            // * 2부터 9까지의 숫자를 받아 해당하는 구구단을 출력
            // * 예시)
            // * 구구단을 출력할 숫자를 입력하세요.(2~7):
            // * 구구단 7단
            // * 7*1=7
            // * .
            // * .
            // * .
            // * 7*9=63
            // */

            //Console.Write("구구단을 출력할 숫자를 입력하세요.(2~9):");
            //string input=Console.ReadLine();
            //int value=int.Parse(input);
            //Console.WriteLine($"구구단 {value}단");
            ////int output;
            //for (int i = 1; i < 10; i++)
            //{
            //    //output =value * i;
            //    Console.WriteLine($"{value} * {i} = {value*i}");//value*i => output
            //}

            //다중 반복문-반복문안에 반복문을 넣는 것
            //for(int i= 0; i< 5 ; i++){
            //      i변수를 선언한 for문에서 반복적으로 실행할 코드
            //      for(int j=0; j<5; j++){
            //              j변수로 선언한 for문의 반목할 코드
            //          }
            //}

            /*문제
             * 별찍기
             * 1)왼쪽 정렬된 직각 삼각형
             * *
             * **
             * ***
             * ****
             * 2)오른쪽 정렬된 직각 삼각형
             *    *
             *   **
             *  ***
             * ****
             * 3)피라미드
             *   *  
             *  ***
             * *****
             * 3)다이아몬드
             *    *
             *   ***
             *  *****
             *   ***
             *    *
             *  
             */

            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int j = 1; j <= i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//왼쪽 정렬
            //for (int i = 5; i >= 1; i--)
            //{
            //    for (int j = 1; j <= i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();

            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int j = 1; j <= (5 - i); j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int k = 1; k <= i; k++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//오른쪽 정렬

            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int j = 1; j <= (5 - i + 1); j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//왼쪽 역 정렬
            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int j = 1; j <= (5 - i + 1); j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int k = 1; k <= i; k++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//오른쪽 역 정렬

            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int l = 1; l <= i + 1; l++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 1; j <= 5 - i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    for (int k = 1; k <= (5 - i + 1); k++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//역피라미드

            //for (int i = 1; i <= 5; i++)
            //{
            //    for (int j = 1; j <= (5 - i + 1); j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int k = 1; k <= i; k++)
            //    {
            //        Console.Write("*");
            //    }
            //    for (int l = 1; l <= i - 1; l++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //Console.WriteLine();//피라미드
            //int count = 3;
            //int line;
            //line = count / 2;
            //for (int i = 0; i < line; i++)
            //{
            //    for (int j = 0; j < (line - i); j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int k = 0; k <= i - 1; k++)
            //    {
            //        Console.Write("*");
            //    }
            //    for (int l = 0; l <= i; l++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}

            //for (int i = 0; i < line; i++)
            //{
            //    for (int l = 0; l < i + 2; l++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 0; j < line - i - 2; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    for (int k = 0; k < (line - i - 1); k++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}


            //for (int i = 0; i < 5; i++)
            //{
            //    for (int j = 0; j < 5 - i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}


            //int count = 31;
            //int line;
            //line = count / 2;
            //for (int i = 1; i <= line; i++)
            //{
            //    for (int j = 0; j < line - i; j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 0; j < 2 * i - 1; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //for (int i = 1; i <= line; i++)
            //{
            //    for (int j = 0; j < i; j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 0; j < 2 * (line - i) - 1; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //int line = 6;

            //for (int i = 1; i <= line; i+=2)//i는 별의 갯수
            //{
            //    for (int j = 1; j <= (line-i)/2; j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 1; j <= i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}
            //for (int i = line - 2 ; i >= 1; i -=2)//i는 별의 갯수
            //{
            //    for (int j = 1; j <= (line - i) / 2; j++)
            //    {
            //        Console.Write(" ");
            //    }
            //    for (int j = 1; j <= i; j++)
            //    {
            //        Console.Write("*");
            //    }
            //    Console.WriteLine();
            //}


            //객체 vs 값
            //객체(Object): Class로 부터 생성된 실체(Instance), Class는 설계도(템플릿)이고 실제는 메모리에 생성된 데이터이다.
            //Class: 데이터와 그 데이터와 관련된 데이터를 다루는데 필요한 기능들을 하나의 단위로 묶어서 관리한다.
            //Class를 통해서 생성된 실체를 객체하고 부른다.
            //값 vs 객체의 차이가 중요

            //예) 여러 학생을 관리 학생1:홍길동, 20 학생2:홍길순, 22 ... 여러학생들의 정보를 일일히 변수로 정의해줘야하는 번거로움이 늘어난다.또한 한번에 관리기가 힘듦
            //데이터가 많아질 수록 데이터를 묶어서 관리할 필요성이 생김 이떄 Class를 관리하기 위해 객체라는 개념이 등장
            //Class를 정의 하고 이에 표함될 데이터를 선언 =>feild(필), 프로터티(속성)
            //같은 Class의 데이터라도 각각의 클래스들을 분리하여 관리 => Object(객체), Class로 부터 생성된 실체

            //Class 선언 및 사용
            //Students _student1 = new Students();//새로운 클래스의 실체를 생성
            //_student1.age = 20;
            //_student1.name= "홍길동";//Student에 필요한 데이터들을 가져올 수 있다.
            //Students _student2 = new Students();//새로운 클래스의 실체를 생성
            //_student2.age = 25;
            //_student2.name = "홍길순";
            //Students _student3 = new Students();//새로운 클래스의 실체를 생성
            //_student3.age = 22;
            //_student3.name = "홍길철";

            //값 타입 변수: 변수의 직접 데이터를 저장 예)int a=10, b=a; b=50;
            //메모리: 
            //Number num1 = new Number();//참조 타입 변수
            //num1.Value = 10;//num1.Value에 10을 할당
            //Number num2 = num1;//num1이 가르키는 주소를 num2에 저장
            //num2.Value = 20;//num2가 가르키는 주소= num1이 가르키는 주소이기 때문에 num1.Value 가 20으로 바뀐다.
            //Console.WriteLine(num1.Value);
            //Console.WriteLine(num2.Value);

            //C#에서 제공하는 클래스들
            //1.배열: 같은 타입의 여러 데이터들을 순서대로 저장하기 위한 데이터 구조/클래스는 아니지만 참조형 데이터
            //int[] _Ages = new int[5];//[]:  배열의 인덱스
            //_Ages[0] = 10;
            //_Ages[1] = 20;
            //_Ages[2] = 30;
            //_Ages[3] = 40;
            //_Ages[4] = 50;

            //int[] _Ages2 = _Ages;
            //_Ages2[0] = 60;
            //_Ages2[1] = 7                                                                                     0;

            //for (int i = 0; i < _Ages.Length; i++)
            //{
            //    Console.WriteLine(_Ages[i]);
            //}

            //1부터 10까지 저장되어있는 배열을 선언하고
            //for문으로 배열의 요소들을 모두 더해서 그 결과를 출력하세요
            //int[] nums = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };
            //int sum=0;
            //for (int i = 0; i < nums.Length; i++)
            //{
            //    sum += nums[i];
            //}
            //Console.WriteLine(sum);

            ////Console.WriteLine(nums.Sum());

            ////1~까지 배열의 짝수의 합을 출력
            //sum = 0;
            //for (int i = 0;i < nums.Length; i++)
            //{
            //    if (nums[i]%2==0) {
            //        sum += nums[i];
            //    }
            //}
            //Console.WriteLine(sum);

            //int[] numbers= {5,10,60,45,15,30}에서 최댓값,최솟값 출력

            //int[] numbers = {5,10,60,45,15,30};

            //int max= numbers[0], min=numbers[0];

            //for (int i = 0; i < numbers.Length; i++)
            //{
            //    if (max < numbers[i])
            //    {
            //        max = numbers[i];
            //    }
            //}
            //Console.WriteLine(max);
            //for (int i = 0; i < numbers.Length; i++)
            //{
            //    if (min > numbers[i])
            //    {
            //        min = numbers[i];
            //    }
            //}
            //Console.WriteLine(min);


            //Console.WriteLine(numbers.Max());
            //Console.WriteLine(numbers.Min());

            //2.List: 가변 배열, 크기가 고정되어 배열과 달리 크기를 동적으로 바꿀 수 있는 배열
            //일반 배열 vs 가변 배열// 일반배열:크기 고정,가변배열:크기가 변할 수 있음

            //List<변수형> 변수명 = new List<변수형>();
            //    List<int> ints = new List<int>();
            //    ints.Add(1);
            //    ints.Add(2);
            //    ints.Add(3);

            //    for (int i = 0; i < ints.Count; i++)
            //    {
            //        Console.WriteLine(ints[i]);
            //    }
            //    //list를 일반 배열로 변환 가능
            //    int[] ints1 = ints.ToArray();
            //    for (int i = 0; i < ints1.Length; i++)
            //    {
            //        Console.WriteLine(ints1[i]);
            //    }

            //    ints.Remove(3);
            //    ints.RemoveAt(0);
            //    for (int i = 0; i < ints.Count; i++)
            //    {
            //        Console.WriteLine(ints[i]);
            //    }

            //    //List 특정 요소를 포함하고 있는지 확인
            //    Console.WriteLine($"Is include 2? {ints.Contains(2)}");
            //    Console.WriteLine($"Is include 2? {ints.Contains(1)}");

            //    //리스트 정렬
            //    ints.Add(321);
            //    ints.Add(542);
            //    ints.Add(456);
            //    ints.Add(354);
            //    ints.Add(457);
            //    ints.Add(555);
            //    ints.Add(635);
            //    ints.Sort();
            //    for (int i = 0; i < ints.Count; i++)
            //    {
            //        Console.Write(ints[i] + " ");
            //    }

            //    Solution solution = new Solution();
            //    solution.solution(ints1);
            //}
            //public class Solution
            //{
            //    public int[] solution(int[] numbers)
            //    {
            //        int[] answer = new int[] { };
            //        for (int i = 0; i < numbers.Length; i++)
            //        {
            //            answer[i] = numbers[i] * 2;
            //        }
            //        return answer;
            //    }
            //}

            //학생 클래스
            //class Students
            //{
            //    public int age;
            //    public string? name;
            //}
            //class Number
            //{
            //    public int Value;
            //}
            //3. Dictionary
            //키와 값을 쌍으로 데이터 관리
            //List나 배열은 1가지 타입으로만 데이터를 저장하고 관리,Dictionary는 Key,Value 2가지 데이터를 저장하고 관리
            //Key는 Dictionary 내에서 고유한 값을 가진다=>중복x
            //동적으로 크기를 조절 가능
            //Dictionary<string, string> cap = new Dictionary<string, string>();
            ////데이터 추가 => 값 또는 키 하나만 추가x, 동시에 추가해야함
            //cap.Add("키", "값");
            //cap.Add("South Korea", "seoul");
            //cap.Add("United States", "Washingten D.C");
            //Console.WriteLine(cap["South Korea"]);
            ////키 존재 여부 확인
            //if (cap.ContainsKey("North Korea"))
            //{
            //    Console.WriteLine($"North Korea에 해당하는 값은 {cap["North Korea"]}입니다.");
            //}
            //else
            //{
            //    Console.WriteLine($"North Korea에 해당하는 키는 없습니다.");
            //}
            ////값 존재 여부 확인
            //if (cap.ContainsValue("seoul"))
            //{
            //    Console.WriteLine($"seoul에 해당하는 값이 있습니다.");
            //}
            //else
            //{
            //    Console.WriteLine($"seoul에 해당하는 값은 없습니다.");
            //}
            //cap.Remove("키");
            ////foreach문: 컬렉션(list,dictionary 등등) 또는 배열의 모든 요소를 순회한다.
            ////foreach(변수 in 컬렉션)
            ////{
            ////      변수에 대한 처리
            ////}
            //int[] intarr = { 1, 2, 3, 4, 5, 6 };//배열의 요소를 순회하는 foreach문
            //foreach (int v in intarr)
            //{
            //    Console.WriteLine($"intarr에 있는 요소는{v}입니다.");
            //    //v *= 2;foreach문에서는 배열의 요소를 직업 수정할 수 없다.
            //}
            ////Dictionary 요소를 순회하는 foreach문
            //foreach (KeyValuePair<string,string> entry in cap)
            //{
            //    Console.WriteLine($"cap Dictionary에는 {entry.Key}와 {entry.Value}를 가지고 있습니다.");
            //}
            //cap.Clear();

            //Class는 데이터와 메서드를 하나의 단위로 묶어서 관리하는 데이터 구조==>list,dictionary또한 class로 만들어져 있다.
        }
    }
}
==============================================================================================================================
using System.Diagnostics;
using System.Dynamic;
using System.Globalization;
using System.Net;

namespace C_study20250222
{
    internal class Program
    {
       //Class는 데이터와 메서드를 하나의 단위로 묶어서 관리하는 데이터 구조==>list,dictionary또한 class로 만들어져 있다.
       //클래스의 구성요소
       //필드 : 클래스 내부에 정의된 변수 => 클래스 내부에서 어디든지 사용 가능
       //메서드 : 클래스 내부에 정의된 함수
       //특징
       //1.은닉성: 클래스 내부에 세부 구현을 숨기고 필요한 부분만 노출할 수 있도록 하는 것
            //public:외부에서 자유롭게 수정 및 사용할 수 있도록 하는 키워드
            //private:           ...           사용할 수 없도록 하는 키워드, 기본적으로 사용되는 키워드


        //메서드(함수) : 특정 작업을 수행하는 코드 블록을 의미
        //메서드 선언
        //반환값 메서드이름(매개변수)
        //{
        //  내부에서 처리할 로직
        //}
        class Calculate
            //계산기 class
            //1.사칙연산
            //2.외부에서 어떤 2가지 값을 넣어주면 그에 해당하는 결과를 받아야한다.
            //3.외부에서 얼마만큼 값을 더해줄지 외부에서 값을 받아와여한다.
        {
            //public int a = 10; private int b = 20;//필드
            ////메서드(함수)
            ////Hello World를 출력하는 메서드=>반환값이 필요없는 매서드는 void 라는 반환값을 사용

            //public void PrintHelloWorld()
            //{
            //    Console.WriteLine($"a의 값은{a}입니다.");
            //    Console.WriteLine($"b의 값은{b}입니다.");
            //    Console.WriteLine("Hello World!");//메서드 내부에서 돌아가는 코드 출력
            //}
            public int value;

            //어떤 값을 더하는 기능:외부에서 접근 가능,결과값을 반환받아야함,반환값이 필요할 때에는 어떤 
            //타입을 반환할지 선언해야함.
            //외부에서 정할 수 있는 값 => 매개변수//해당 메서드내에서만 사용
            public int Add(int a)
            {
                return value+a;//반환해주는 키워드, return을 사용하면 메서드는 바로 종료된다.
            }
        }
        static void Main(string[] args)
        {
            Calculate calculate = new Calculate();
            calculate.value = 100;
            int result = calculate.Add(30);//값을 받아올 수 있다.
            Console.WriteLine(result);
        }
    }
}
===========================================================================================================================
using System.Diagnostics;
using System.Dynamic;
using System.Globalization;
using System.Net;

namespace C_study20250222
{
    internal class Program
    {
        //빼기,나누기,나머지,곱하기 기능을 하는 메서드들을 만든다.
        //value값을 초기화 해주는 함수를 만든다 ==>Init(int amount)함수를 만든다.
        //출력 결과
        //계산기에 오신걸 환영합니다.
        //초기 값을 입력해주세요 : 10
        //계산형 방식을 정해주세요 1)더하기 2)빼기 3)곱하기 4)나누기 5)나머지 :1
        //얼만큼 더할건지 알려주세요 : 50
        //계산된 결과값은 60 입니다.
        static void Main(string[] args)
        {
            Calculate calculate = new Calculate();

            Console.WriteLine("계산기에 오신걸 환영합니다.");

            Console.Write("초기값을 입력해 주세요. : ");
            calculate.Init(int.Parse(Console.ReadLine()));

            Console.Write("계산할 방식을 정해주세요. 1)더하기, 2)빼기, 3)곱하기, 4)나누기, 5)나머지 : ");
            string method= Console.ReadLine();

            switch (method)
            {
                case "1":
                    Console.Write("얼만큼 더할건지 알려주세요. : ");
                    Console.WriteLine($"계산된 결과 값은 {calculate.Add(int.Parse(Console.ReadLine()))}입니다.");
                    break;
                case "2":
                    Console.Write("얼만큼 뺄건지 알려주세요. : ");
                    Console.WriteLine($"계산된 결과 값은 {calculate.Sub(int.Parse(Console.ReadLine()))}입니다.");
                    break;
                case "3":
                    Console.Write("얼만큼 곱할지 알려주세요. : ");
                    Console.WriteLine($"계산된 결과 값은 {calculate.Mul(int.Parse(Console.ReadLine()))}입니다.");
                    break; 
                case "4":
                    Console.Write("얼마로 나눌지 알려주세요. : ");
                    Console.WriteLine($"계산된 결과 값은 {calculate.Div(int.Parse(Console.ReadLine()))}입니다.");
                    break;
                case "5":
                    Console.Write("얼마로 나눌지 알려주세요. : ");
                    Console.WriteLine($"계산된 결과 값은 {calculate.Rem(int.Parse(Console.ReadLine()))}입니다.");
                    break;
            }
        }
        class Calculate
        {
            private int value;
            public void Init(int amount)
            {
                value = amount;
            }

            public int Add(int amount)
            {
                return value + amount;
            }
            public int Sub(int amount)
            {
                return value - amount;
            }
            public int Div(int amount)
            {
                if (amount == 0)
                    return value;
                return value / amount;
            }
            public int Mul(int amount)
            {
                return value * amount;
            }
            public int Rem(int amount)
            {
                if (amount == 0)
                    return value;
                return value % amount;
            }
        }
    }
}
=============================================================================================================================
using System.Diagnostics;
using System.Dynamic;
using System.Globalization;
using System.Net;

namespace C_study20250222
{
    internal class Program
    {
        //빼기,나누기,나머지,곱하기 기능을 하는 메서드들을 만든다.
        //value값을 초기화 해주는 함수를 만든다 ==>Init(int amount)함수를 만든다.
        //출력 결과
        //계산기에 오신걸 환영합니다.
        //초기 값을 입력해주세요 : 10
        //계산형 방식을 정해주세요 1)더하기 2)빼기 3)곱하기 4)나누기 5)나머지 :1
        //얼만큼 더할건지 알려주세요 : 50
        //계산된 결과값은 60 입니다.
        //메서드 오버로딩(OverRoading)
        //동일한 이름을 가진 메서드를 여러 개 정의하여, 서로 다은 매개변수를 사용할 수 있게 하는 기능
        static void Main(string[] args)
        {
            Calculate calculate = new Calculate();

            Console.WriteLine("계산기에 오신걸 환영합니다.");

            Console.Write("초기값을 입력해 주세요. : ");
            calculate.Init(int.Parse(Console.ReadLine()));

            Console.Write("계산할 방식을 정해주세요. 1)더하기, 2)빼기, 3)곱하기, 4)나누기, 5)나머지 : ");
            string method = Console.ReadLine();

            double result=0;

            switch (method)
            {
                case "1":
                    Console.Write("얼만큼 더할건지 알려주세요. : ");
                    result = calculate.Add(int.Parse(Console.ReadLine()));
                    break;
                case "2":
                    Console.Write("얼만큼 뺄건지 알려주세요. : ");
                    result = calculate.Sub(int.Parse(Console.ReadLine()));
                    break;
                case "3":
                    Console.Write("얼만큼 곱할지 알려주세요. : ");
                    result = calculate.Mul(int.Parse(Console.ReadLine()));
                    break;
                case "4":
                    Console.Write("얼마로 나눌지 알려주세요. : ");
                    result = calculate.Div(float.Parse(Console.ReadLine()));
                    break;
                case "5":
                    Console.Write("얼마로 나눌지 알려주세요. : ");
                    result = calculate.Rem(int.Parse(Console.ReadLine()));
                    break;
            }
            Console.WriteLine($"계산된 결과 값은 {result}입니다.");
        }
        class Calculate
        {
            private int value;
            public void Init(int amount)
            {
                value = amount;
            }

            public int Add(int amount)
            {
                return value + amount;
            }
            public int Sub(int amount)
            {
                return value - amount;
            }
            public int Div(int amount)
            {
                if (amount == 0)
                {
                    Console.WriteLine("0으로 나눌 수 없습니다.");
                    return value;
                }
                return value / amount;
            }
            public int Mul(int amount)
            {
                return value * amount;
            }
            public int Rem(int amount)
            {
                if (amount == 0)
                {
                    Console.WriteLine("0으로 나눌 수 없습니다.");
                    return value;
                }    
                    
                return value % amount;
            }
            public float Div(float amount)
            {
                if (amount == 0)
                {
                    Console.WriteLine("0으로 나눌 수 없습니다.");
                    return value;
                }
                return (float)value / amount;
            }
        }
    }
}
===========================================================================================================================
using System.Reflection.Metadata.Ecma335;

namespace ConsoleApp2
{
    internal class Program
    {
        // TRPG 게임
        // Player Class : 플레이어 캐릭터
        // Monster Class : 몬스터 캐릭터

        // 모든 캐릭터는 기본적으로 체력과 공격력을 가지고 있습니다.
        // 모든 캐릭터는 공격을 하거나 방어를 할 수 있습니다.
        // 공격을 할 때 상대방이 방어를 하면 데미지를 받지 않습니다.

        // 플레이어랑 캐릭터가 전투를 하는 로직을 구현한다. 
        // 플레이어는 1, 공격, 2, 방어
        // 적의 모든 행동(공격, 방어)은 다 랜덤으로 한다.

        //클래스의 상속성
        //한 클래스의 속성과 메서그를 다른 클래스가 상속받용할 수 있게하는 특징

        //클래스의 다형성
        //같은 인터페이스나 메서드 호출이 서로 다은 객테 타입(class)에 대해 서로 다른 동작을 할 수 있게 해준다.
        //메서드 오버라이팅 : 상속관계에 있는 클래스에서 부모 클래스에 정의된 메서드를 자식 클래스에서 재정의
        //virtual : 부모 클래스에 선언된 메서드를 자식 클래스에서 재정의 할 수 있도록 해주는 키워드

        class Character//플레이어와 몬스터 모두 공통적으로 사용하는 메서드나 필드를 가진 클래스
                       //=> 부모 클래스, 슈터 클래스  |  Player, Monster 클래스 => 자식 클래스, 서브 클래스
                       //Player, Monster 클래스에서 Character라는 부모 클래스의 메서드와 필드를 (사용)상속받는다
        {//플레이어, 몬스터 둘다 사용할 필드, 메서드
         //private는 상속받는 class도 접근이 안된다.protected는 상속받는 class도 접근이 가능하다.
            protected int health; // 체력
            protected int attack; // 공격력

            protected bool isDefence;//방어 여부

            //name 필드를 선언
            protected string name;
            //방어하는 메서드
            public void Defence()
            {
                //해당 class에 선언된 name으로 출력
                Console.WriteLine($"{name}이/가 방어합니다.");
                isDefence = true;
            }
            // 데미지를 받는 메서드
            public virtual void isAttacked(int amount)
            {
                if (isDefence)
                {
                    isDefence = false;
                }
                else
                    health -= amount;

            }
            // => 상대방이 공격력을 넘겨주면
            // 내가 방어하고 있는지 아닌지를 판단해서
            // 체력을 깍는다.
            public void resetDefence()
            {
                isDefence = false;
            }
            public int isHealth()
            {
                return health;
            }
        }
        class Player : Character//=> Player 는 Character 클래스를 상속받는다
        {

            public Player(string initialname, int initialhealth,int initialattack,bool initialisDefence)
            {
                name = initialname;
                health = initialhealth;
                attack = initialattack;
                isDefence = initialisDefence;
            }
            // 공격하는 메서드
            public void Attack(Monster monster)
            {
                Console.WriteLine("몬스터를 공격했습니다.");
                if (!isDefence)
                    monster.isAttacked(attack);
            }
            //player는 데미지를 받을 때마다 50%로 공격력 2배
            public override void isAttacked(int amount)
            {
                base.isAttacked(amount);//부모 계층을 의미//Character class의 isAttacked의 메서드 로직
                //확률 계산
                Random rand = new Random();
                int random = rand.Next(0,100);
                if (random < 50)
                {
                    attack += 5;
                    Console.WriteLine($"{name}특성 활성화 | 공격력 5 증가");
                }
            }
            //~Player()
            //{
            //    //리소스 정리
            //}

        }

        class Monster : Character
        {
            
            public Monster(string initialname, int initialhelth,int initialattack,bool initialisDefense)
            {
                name = initialname;
                health = initialhelth;
                attack = initialattack;
                isDefence = initialisDefense;
            }
            // 공격하는 메서드
            public void Attack(Player player)
            {
                Console.WriteLine("몬스터가 공격했습니다.");
                if (!isDefence)
                    player.isAttacked(attack);
            }
            //데미지를 받을때마다 30%로 체력을 50씩 회복
            public override void isAttacked(int amount)
            {
                base.isAttacked(amount);//부모 계층을 의미//Character class의 isAttacked의 메서드 로직Random rand = new Random();
                Random rand = new Random();
                int random = rand.Next(0, 100);
                if (random < 30)
                {
                    health += 50;
                    Console.WriteLine($"{name}특성 활성화 | 체력 50 회복");
                }
            }
        }

        static void Main(string[] args)
        {
            // 플레이어의 초기 스텟을 설정
            Player player = new Player("플레이어",100,10,false);

            // 몬스터의 초기 스텟을 설정
            Monster monster = new Monster("고블린",75,10,false);

            // 전투 시작
            Console.WriteLine("야생의 고블린이 나타났습니다.");
            Console.WriteLine("전투를 시작합니다.");

            Console.WriteLine($"플레이어 체력 : {player.isHealth()}  |  몬스터 체력 : {monster.isHealth()}");

            // 몬스터 혹은 플레이어 둘다 살아 있는 동안에는 계속 전투를 한다.
            while (monster.isHealth() > 0 && player.isHealth() > 0)
            {
                Random rand = new Random();

                int monsterAction = rand.Next(1, 3);// 1 혹은 2

                Console.Write("\n플레이어 턴입니다. 행동을 선택하세요(1번 공격, 2번 방어) : ");
                string input = Console.ReadLine();
                int choice = int.Parse(input);

                if (choice == 2)
                {
                    player.Defence();
                }
                if (monsterAction == 2)
                {
                    monster.Defence();
                }

                // 공격 로직를 실행한다.
                if (choice == 1)
                {
                    // 공격 메소드 실행
                    player.Attack(monster);
                }
                if (monsterAction == 1)
                {
                    monster.Attack(player);
                }


                player.resetDefence();
                monster.resetDefence();
                
                Console.WriteLine($"플레이어 체력 : {player.isHealth()}  |  몬스터 체력 : {monster.isHealth()}");
            }
            if (monster.isHealth() <= 0)
            {
                Console.WriteLine("\n플레이어가 승리했습니다.");
            }
            else if (player.isHealth() <= 0)
            {
                Console.WriteLine("\n플레이어가 패배했습니다.");
            }
        }
        //클래스의 생성자와 소멸자
        //클래스의 생성자 : 클래스의 인스턴스(객체)가 생성될 때 자동우로 호출되는 메서드
        //생성자의 주된 목적은 객체의 초기화, 즉 필드의 초기값을 설정

        //클래스의 소멸자(C#에서는 가비지 컬렉터가 있어서 리소스를 자동으로 절리하기 때문에 직접작성할 필요 x)
        // : 객체가 더이상 필요 없어 메모리에서 해제될 때 자동으로 호출되는 메서드
        //소멸자의 주된 목적은 사용한 리소스를 정리(파일 닫기, 네트워크 연결 해제...)
    }
}

========================================================================================================================
using System.Reflection.Metadata.Ecma335;

namespace ConsoleApp2
{
    internal class Program
    {
        // 캐릭터와 아이템 장착
        // Player 클래스와 Item 클래스를 구현하여, RPG 게임에서 아이템을 착용해서 캐릭터의 공격력을 증가시키는 코드를 작성
        // 아이템을 장착하면 공격력이 증가하고, 아이템이 없어도 기본적으로 공격력은 가지고 있어야 합니다.
        /*
         요구사항:
            아이템 클래스 (Item)
                Item 클래스는 아래와 같은 속성들을 가집니다:
                    - Name: 아이템의 이름 (예: "철검", "방패")
                    - AttackBonus: 아이템이 제공하는 공격력 보너스 (정수형)
                Item 클래스의 생성자는 Name과 AttackBonus를 받아 초기화해야 합니다.

            플레이어 클래스 (Player)
            Player 클래스는 아래와 같은 속성들을 가집니다:
                - Name: 플레이어의 이름 (예: "영웅")
                - Attack: 기본 공격력 (정수형)
                - EquippedItem: 현재 착용한 아이템을 저장하는 속성 (Item 객체)
                - EquipItem 메서드: 아이템을 착용하는 메서드입니다. null을 전달하면 아이템을 해제합니다.
                - DisplayAttackPower 메서드: 플레이어의 총 공격력을 계산하여 출력하는 메서드입니다. 아이템이 착용되었을 경우, 아이템의 공격력 보너스를 추가합니다.

            조건
            - 아이템이 착용된 경우, Attack에 Item.AttackBonus 값을 더한 총 공격력을 계산하여 출력해야 합니다.
            - 아이템이 null인 경우, Attack 값만 출력되어야 합니다.
            
            Main 메서드
            - Player 객체를 생성하고, Item 객체를 생성하여 아이템을 착용하고 공격력을 출력하는 프로그램을 작성합니다.
         */

        // 출력 예시
        // 영웅의 총 공격력: 10
        // 영웅은 철검을 착용했습니다.
        // 영웅의 총 공격력: 15
        // 영웅은 아이템을 해제했습니다.
        // 영웅의 총 공격력: 10

        // 선택 사항 아이템을 선택하여 장착하는 시스템을 만들어 주세요
        class Player
        {
            private string name;
            private int Attack;
            public int AttackPower;
            private Item EquippedItem;
            public Player(string name,int Attack)
            {
                this.name = name;
                this.Attack = Attack;
                EquippedItem = null;
            }
            
            public void EquipItem(Item item)
            {
                if (item != null)
                {
                    EquippedItem = item;
                    Console.WriteLine($"{this.name}이/가 {EquippedItem.name}을/를 착용하였습니다.");
                }
                else if (item == null)
                {
                    EquippedItem = null;
                    Console.WriteLine($"{this.name}이/가 아이템을 해제하였습니다.");
                }
            }
            public void DisplayAttackPower()
            {
                if (EquippedItem != null)
                    this.AttackPower = this.Attack + EquippedItem.AttackBonus;
                else
                    this.AttackPower = this.Attack;

                Console.WriteLine($"{this.name}의 총 공격력 : {this.AttackPower}");
            }
        }
        class Item
        {
            public int AttackBonus;
            public string name;
            public Item(string name,int AttackBonus)
            {
                this.name=name;
                this.AttackBonus = AttackBonus;
            }
        }

        static void Main(string[] args)
        {
            Item sword = new Item("철검",5);
            Item Sheild = new Item("방패", 3);
            Player player = new Player("영웅",10);

            player.DisplayAttackPower();

            Console.WriteLine($"착용할 아이템을 선택하세요.\n 1. {sword.name} \n 2. {Sheild.name}");
            string Choice = Console.ReadLine();
            switch (Choice)
            {
                case "1":
                    player.EquipItem(sword);
                    player.DisplayAttackPower();
                    player.EquipItem(null);
                    player.DisplayAttackPower();
                    break;
                case "2":
                    player.EquipItem(Sheild);
                    player.DisplayAttackPower();
                    player.EquipItem(null);
                    player.DisplayAttackPower();
                    break;
            }
        }
    }
}

=============================================================================================================
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace ConsoleApp2
{
    internal class Program
    {
        //String : 문자의 배열
        //string => 객체
        //문자열 불변성
        //C#에서는 문자열은 *불변 객체*이다.
        //불변 객체는 생성된 이후 그 값을 변경할 수 없다.
        //문자열을 변경하는 것처럼 보이는 작업은 실제로는 새로운 문자열 객체를 생성하는 것이다.

        //string oringinal = "Hello";
        //string modified = oringinal + " world";
        //Console.WriteLine(oringinal);

        //새로운 문자를 추가하는 행위도 계속해서 객체를 만드는 것이기 때문에
        //컴퓨터 입장엔 무거운 작업이다.

        //System.Text.StringBuilder sb = new System.Text.StringBuilder();
        //StringBuilder을 사용하여 부하를 줄인다.

        //문자열이 자주 변경되어야 할때 StringBuilder를 사용하는 것이 효율적이다.
        //StringBuilder는 가변 객체로, string 같은 불변 객체보다 메모리와 성능 측면에서 유리하다.
        static void Main(string[] args)
        {
            StringBuilder sb = new StringBuilder();
            //문자열을 StringBuilder에 추가(Append)

            sb.Append("Hello");
            sb.Append(" ");
            sb.Append("World");
            sb.AppendLine();//줄바꿈 포함

            string result = sb.ToString();
            Console.WriteLine(result);
            //새롭게 문자를 처음부터 할당
            sb.Clear();//기존 문자 삭제 및 초기화

        }
    }
}

===========================================================================================================

using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace ConsoleApp2
{
    internal class Program
    {
        //문자열 포멧팅
        //문자를 특정 형식에 맞게 출력하고 싶을 때 
        //소수점 아래 두자리 표시, 통화 형식 표시, 날씨 형식 표시, 정수 형식 표시

        
        static void Main(string[] args)
        {
            //소수점 두자리
            double pi = 3.14159265;
            string formatpi = $"Pi is {pi:f2}";
            Console.WriteLine(formatpi);

            //통화 형식(콤마표시)
            double price = 199000000.99;
            string formatprice = $"Price is {price:n0}";
            Console.WriteLine(formatprice);

            //날짜 표시
            DateTime dateTime = DateTime.Now;
            string fomatdate = $"Today is {dateTime:H:m:s}";
            Console.WriteLine(fomatdate);

            //정수 형식 표시
            int num = 1234 ;
            string formatnum = $"number : {num:d8}";//부족한 만큼 0으로 채우기
            Console.WriteLine (formatnum);
        }
    }
}

============================================================================================================================

using System.Diagnostics;
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace ConsoleApp2
{
    internal class Program
    {
        // String 관련 메소드
        // - Length: 문자열의 길이를 반환합니다.
        // - Substring: 문자열의 일부를 추출합니다.
        // - IndexOf: 특정 문자의 첫 번째 위치를 찾습니다.
        // - ToUpper / ToLower: 문자열을 대문자 또는 소문자로 변환합니다.
        // - Trim: 문자열의 앞뒤 공백을 제거합니다.
        // - Replace: 특정 문자열을 다른 문자열로 교체합니다.
        // - Split: 문자열을 특정 구분자를 기준으로 나누어 배열로 반환합니다.
        // String.TryParse() 와 Ref, out 키워드
        // Generic
        // Delegate, Event, Action, Func
        static void Main(string[] args)
        {
            // 1, Length : 문자열의 길이를 반환합니다.
            string text = "Hello, World!";
            int length = text.Length;
            Console.WriteLine($"문자열의 길이는 : {length}입니다.");

            // 2, Substring : 문자열에서 문자열 일부분을 추출하는 메서드
            // Substring(추출을 시작할 인덱스, 추출할 문자열의 길이)
            text = "Hello, World!";
            string subText = text.Substring(0,5);
            Console.WriteLine($"추출한 문자열 : {subText}");
            Console.WriteLine($"추출하고 남은 문자열 : {text}");

            // 3, IndexOf : 특정 문자의 첫 번째 위치를 찾습니다.
            //    LastIndexOf : 특정 문자의 마지막 위치를 찾습니다.
            text = "Hello, World!";
            int firstIndex = text.IndexOf('o');
            int lastIndex = text.LastIndexOf('o');
            Console.WriteLine($"'o'의 첫번쨰 위치(인덱스)는 : {firstIndex}입니다.");
            Console.WriteLine($"'o'의 마지막 위치(인덱스)는 : {lastIndex}입니다.");

            // 4, ToUpper, ToLower : 문자열을 대문자 또는 소문자로 변환합니다.
            text = "Hello, World!";
            string upperText = text.ToUpper();
            string lowerText = text.ToLower();
            Console.WriteLine($"대문자 변환 : {upperText}");
            Console.WriteLine($"소문자 변환 : {lowerText}");

            // 5, Trim : 문자열의 앞뒤 공백을 제거합니다.
            string textWithSpace = "    Hello, World!     ";
            string trimmedText = textWithSpace.Trim();
            Console.WriteLine($"문자열의 앞뒤 공백이 삭제된 문자열 {trimmedText}");

            // 6, Replace : 문자열에 특정 문자열을 다른 문자열로 교체합니다.
            text = "Hello, World!";
            string replacedText = text.Replace("World", "CSharp");
            Console.WriteLine($"교체된 문자열 : {replacedText}");
            Console.WriteLine($"교체되기 전 문자열 : {text}");

            // 7, Split : 문자열을 특정 구분자를 기준으로 나누어 배열로 반환합니다.
            string fruitString = "Apple,Banana,Cherry,Mango";
            string[] fruits = fruitString.Split(',');
            Console.WriteLine("Split 메서드 실행");
            for(int i = 0; i < fruits.Length; i++)
            {
                Console.WriteLine(fruits[i]);
            }
        
        }
    }
}
=========================================================================================================================
using System.Diagnostics;
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace ConsoleApp2
{
    internal class Program
    {
        // String.TryParse() 와 Ref, out 키워드
        // Generic
        // Delegate, Event, Action, Func

        // ref와 out 키워드는 메서드와 상호작용하는 데 중요한 방법을 제공합니다.
        // 메서드로부터 여러 값을 받환받고 싶은 상황 => out
        // 메서드 내에서 변수의 값을 변경할 수 있도록 하고 싶은 상황 => ref
        public class Parser
        {
            // string값을 넘겨주면 string을 int로 바꿔서 그 결과값을 반환도 하고싶다
            // string값이 Parsing 이 가능한지를 먼저 판단을 하고 싶다. => 가능하면 결과값을 반환
            public bool TryParse(out int result)
            {
                result = 10;
                return false;
            }

            public void Add(int a, int b , ref int result)
            {
                result = a + b;
            }

            public void Add(int a, int b, int result)
            {
                result = a + b;
            }
        }

        static void Main(string[] args)
        {
            // String.TryParse();
            // Parse()
            string number = "123asd";
            int resuilt = 10;
            bool successParsing = int.TryParse(number, out int result);
            Console.WriteLine($"파싱 성공 : {successParsing} , 파싱 결과 : {result}");
            // out 키워드는 메서드로 부터 특정 변수 값을 반환받은 키워드
            // out 키워드를 사용해서 메서드를 구현하면 해당 메서드는 out 키워드에 해당하는 변수를 만들어서 
            // 반환을 시켜줍니다.
            //Parser parser = new Parser();
            //bool successParse = parser.TryParse(out int result);
            //int result = 15;
            //Console.WriteLine($"파싱 성공 : {successParse} , 파싱 결과 : {result}");

            // ref 키워드는 메서드에게 참조 형식으로 변수를 넘겨줄 수 있는 키워드입니다.
            // 메서드 내에서 ref 키워드를 사용한 변수를 수정하면 변경된 상태에서 코드를 작업할 수 있습니다.
            // 기본적으로 메서드 내에서 사용한 로직, 연산 처리는 메서드 내에서만 유지가 됩니다.
            // => 왜냐하면 메서드에게 매개변수로 값을 넘길떄는 참조 형식이 아니라 복사형식으로 값을 넘겨줍니다.
            // 따라서 Add(a, b, result2); 를 실행하더라도 Main 문에 있는 result2의 값은
            // Add(a, b, result2);를 실행하더라도 바뀌지 않습니다.
            // 
            // ref 키워드를 사용하면 매개변수를 참조 형식으로 전달하기 때문에 
            // 메서드 내에서 ref 키워드를 사용한 매개변수를 수정하면 main문에서도 바뀐 결과를 사용할 수 있습니다.
            int a = 5;
            int b = 10;
            int result2 = 0;
            Parser parser = new Parser();
            parser.Add(a, b, result2);
            Console.WriteLine($"{a} + {b} = {result2}");

            parser.Add(a, b, ref result2);
            Console.WriteLine($"{a} + {b} = {result2}");
        }
    }
}
=================================================================================================================
using System.ComponentModel.DataAnnotations;
using System.Diagnostics;
using System.Reflection.Metadata.Ecma335;
using System.Text;

namespace ConsoleApp2
{
    internal class Program
    {
        // static
        // Delegate, Event, Action, Func


        // Generic(일반화)
        // Generic은 메서드 혹은 Class에서 많이 사용하고 다양한 데이터 타입을 처리할 수 있도록 해주는 기능입니다.
        // 계산기 클래스
        public class Calculate
        {
            //// string 데이터 타입을 지원하는 메서드
            //public void PushMessage(string message)
            //{

            //}

            //// int 데이터 타입을 지원하는 메서드
            //public void PushMessage(int message)
            //{

            //}


            // PushMessage는 다양한 데이터 타입을 받을 수가 있습니다.
            public void PushMessage<T>(T message)
            {
                Console.WriteLine($"{typeof(T)} 데이터 타입의 메세지를 받았습니다 {message}");
            }
        }

        // where 키워드를 사용하면 T 에서 받을 수 있는 형식을 제한할 수 있다.
        // where T : class => class 형식만 받을 수 있습니다.
        public class MyList<T> 
        {
            private T[] array = new T[10];

            public void Add(T item, int index)
            {
                array[index] = item;
            }

            public T Get(int index)
            {
                return array[index];
            }
        }

        static void Main(string[] args)
        {
            MyList<int> list = new MyList<int>();
            list.Add(10, 0);
            list.Add(20, 1);
            list.Add(30, 2);

            Console.WriteLine(list.Get(0));
            Console.WriteLine(list.Get(1));
            Console.WriteLine(list.Get(2));

            MyList<string> stringList = new MyList<string>();
            stringList.Add("Hello", 0);
            stringList.Add("World", 1);
            stringList.Add("Csharp", 2);

            Console.WriteLine(stringList.Get(0));
            Console.WriteLine(stringList.Get(1));
            Console.WriteLine(stringList.Get(2));

            Calculate calculate = new Calculate();
            // 부동 소수점 끼리 더하고 싶다면
            // Calculate 클래스 내에서 해당 float 데이터 타입을 지원하는 Add 클래스를 만들어야합니다.
            calculate.PushMessage("안녕하세요");
            calculate.PushMessage(123);
            List<int> ints = new List<int>();
            calculate.PushMessage(ints);
        }
    }
}
=================================================================================================================
